import { load as yamlLoad } from 'js-yaml'
// @ts-expect-error -- internal ESM entry lacks types in this workspace layout.
import transformSchemaImport from '../node_modules/openapi-typescript/dist/transform/index.mjs'
// @ts-expect-error -- internal ESM entry lacks types in this workspace layout.
import * as tsModuleImport from '../node_modules/openapi-typescript/dist/lib/ts.mjs'
// @ts-expect-error -- internal ESM entry lacks types in this workspace layout.
import * as utilsModuleImport from '../node_modules/openapi-typescript/dist/lib/utils.mjs'

type TransformSchema = (schema: unknown, ctx: unknown) => unknown[]
type AstToString = (
  ast: unknown,
  options?: { fileName?: string; sourceText?: string; formatOptions?: Record<string, unknown> },
) => string
type ResolveRef = (
  schema: unknown,
  ref: string,
  options?: { silent?: boolean; visited?: string[] },
) => unknown
type ScanDiscriminators = (
  schema: unknown,
  options: { silent?: boolean },
) => { objects: Record<string, unknown>; refsHandled: string[] }

const transformSchema = transformSchemaImport as TransformSchema
const astToString = tsModuleImport.astToString as AstToString
const resolveRef = utilsModuleImport.resolveRef as ResolveRef
const scanDiscriminators = utilsModuleImport.scanDiscriminators as ScanDiscriminators

export type OpenApiDocument = Record<string, unknown> & { openapi: string }

export type OpenApiParseErrorCode = 'empty' | 'invalid' | 'not-object' | 'unsupported-version'

export type OpenApiParseResult =
  | {
      ok: true
      document: OpenApiDocument
      externalRefs: string[]
    }
  | {
      ok: false
      code: OpenApiParseErrorCode
      message?: string
    }

export type OpenApiTypegenOptions = {
  additionalProperties?: boolean
  alphabetize?: boolean
  arrayLength?: boolean
  defaultNonNullable?: boolean
  emptyObjectsUnknown?: boolean
  enum?: boolean
  enumValues?: boolean
  dedupeEnums?: boolean
  excludeDeprecated?: boolean
  exportType?: boolean
  immutable?: boolean
  pathParamsAsTypes?: boolean
  propertiesRequiredByDefault?: boolean
  rootTypes?: boolean
  rootTypesNoSchemaPrefix?: boolean
  makePathsEnum?: boolean
  generatePathParams?: boolean
  includeHeader?: boolean
  silent?: boolean
}

const HEADER_COMMENT = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

`

export function parseOpenApiDocument(source: string): OpenApiParseResult {
  const trimmed = source.trim()
  if (!trimmed) {
    return { ok: false, code: 'empty' }
  }

  let parsed: unknown
  if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
    try {
      parsed = JSON.parse(trimmed)
    } catch (jsonError) {
      try {
        parsed = yamlLoad(trimmed)
      } catch (yamlError) {
        const message = jsonError instanceof Error ? jsonError.message : String(jsonError)
        const fallback = yamlError instanceof Error ? yamlError.message : String(yamlError)
        return { ok: false, code: 'invalid', message: message || fallback }
      }
    }
  } else {
    try {
      parsed = yamlLoad(trimmed)
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error)
      return { ok: false, code: 'invalid', message }
    }
  }

  if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
    return { ok: false, code: 'not-object' }
  }

  const version = (parsed as { openapi?: unknown }).openapi
  if (typeof version !== 'string' || !version.startsWith('3.')) {
    return { ok: false, code: 'unsupported-version' }
  }

  return {
    ok: true,
    document: parsed as OpenApiDocument,
    externalRefs: collectExternalRefs(parsed),
  }
}

export function collectExternalRefs(value: unknown): string[] {
  const refs = new Set<string>()
  const visit = (node: unknown) => {
    if (!node) return
    if (Array.isArray(node)) {
      node.forEach(visit)
      return
    }
    if (typeof node !== 'object') return

    for (const [key, entry] of Object.entries(node)) {
      if (key === '$ref' && typeof entry === 'string') {
        if (!entry.startsWith('#')) {
          refs.add(entry)
        }
      } else {
        visit(entry)
      }
    }
  }

  visit(value)
  return Array.from(refs)
}

export function generateOpenApiTypes(
  document: OpenApiDocument,
  options: OpenApiTypegenOptions = {},
): string {
  const ctx = {
    additionalProperties: options.additionalProperties ?? false,
    alphabetize: options.alphabetize ?? false,
    arrayLength: options.arrayLength ?? false,
    defaultNonNullable: options.defaultNonNullable ?? true,
    discriminators: scanDiscriminators(document, options),
    emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,
    enum: options.enum ?? false,
    enumValues: options.enumValues ?? false,
    dedupeEnums: options.dedupeEnums ?? false,
    excludeDeprecated: options.excludeDeprecated ?? false,
    exportType: options.exportType ?? false,
    immutable: options.immutable ?? false,
    rootTypes: options.rootTypes ?? false,
    rootTypesNoSchemaPrefix: options.rootTypesNoSchemaPrefix ?? false,
    injectFooter: [] as unknown[],
    pathParamsAsTypes: options.pathParamsAsTypes ?? false,
    propertiesRequiredByDefault: options.propertiesRequiredByDefault ?? false,
    silent: true,
    inject: undefined as string | undefined,
    transform: undefined as unknown,
    transformProperty: undefined as unknown,
    postTransform: undefined as unknown,
    makePathsEnum: options.makePathsEnum ?? false,
    generatePathParams: options.generatePathParams ?? false,
    resolve: (ref: string) => resolveRef(document, ref, { silent: true }),
  }

  const ast = transformSchema(document, ctx)
  const content = astToString(ast)
  if (options.includeHeader === false) {
    return content
  }
  return `${HEADER_COMMENT}${content}`
}
