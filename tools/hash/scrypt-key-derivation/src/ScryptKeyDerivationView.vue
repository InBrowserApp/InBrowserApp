<template>
  <ToolDefaultPageLayout :info="toolInfo">
    <ScryptForm
      v-model:password="password"
      v-model:salt="salt"
      v-model:salt-format="saltFormat"
      v-model:cost-factor="costFactorInput"
      v-model:block-size="blockSizeInput"
      v-model:parallelism="parallelismInput"
      v-model:length="lengthInput"
      :cost-factor-min="minCostFactor"
      :cost-factor-max="maxCostFactor"
      :block-size-min="minBlockSize"
      :block-size-max="maxBlockSize"
      :parallelism-min="minParallelism"
      :parallelism-max="maxParallelism"
      :length-min="minLength"
      :length-max="maxLength"
      :cost-factor-label="costFactorLabel"
      :block-size-label="blockSizeLabel"
      :parallelism-label="parallelismLabel"
      :cost-factor-valid="costFactorValid"
      :cost-factor-power-of-two="costFactorPowerOfTwo"
      :memory-bound-valid="memoryBoundValid"
      :cost-factor-safe-max="costFactorSafeMax"
      :block-size-safe-max="blockSizeSafeMax"
      :block-size-valid="blockSizeValid"
      :parallelism-valid="parallelismState.isValid"
      :length-valid="lengthState.isValid"
      :salt-error-type="saltErrorType"
    />

    <ScryptResult
      :password="password"
      :salt="salt"
      :salt-format="saltFormat"
      :cost-factor="costFactorState.value"
      :block-size="blockSizeState.value"
      :parallelism="parallelismState.value"
      :length="lengthState.value"
      :cost-factor-valid="costFactorValid"
      :block-size-valid="blockSizeValid"
      :parallelism-valid="parallelismState.isValid"
      :length-valid="lengthState.isValid"
      :salt-error-type="saltErrorType"
    />

    <WhatIsScrypt />
  </ToolDefaultPageLayout>
</template>

<script setup lang="ts">
import * as toolInfo from './info'
import { ToolDefaultPageLayout } from '@shared/ui/tool'
import { useStorage } from '@vueuse/core'
import { computed, ref, watch } from 'vue'
import { useI18n } from 'vue-i18n'
import { isValidBase16 } from '@utils/base16'
import type { SaltFormat } from './types'
import {
  generateRandomSalt,
  getMaxBlockSizeForCostFactor,
  getMaxCostFactorForBlockSize,
  isScryptMemoryWithinLimit,
  isValidBase64,
} from './utils'
import ScryptForm from './components/ScryptForm.vue'
import ScryptResult from './components/ScryptResult.vue'
import WhatIsScrypt from './components/WhatIsScrypt.vue'

const { t } = useI18n()

const minCostFactor = 1024
const maxCostFactor = 1048576
const defaultCostFactor = 16384

const minBlockSize = 1
const maxBlockSize = 32
const defaultBlockSize = 8

const minParallelism = 1
const maxParallelism = 16
const defaultParallelism = 1

const minLength = 16
const maxLength = 256
const defaultLength = 32

const costFactorLabel = computed(() => {
  const message = t('cost-factor-label')
  return message === 'cost-factor-label' ? 'N (Cost Factor)' : message
})

const blockSizeLabel = computed(() => {
  const message = t('block-size-label')
  return message === 'block-size-label' ? 'r (Block Size)' : message
})

const parallelismLabel = computed(() => {
  const message = t('parallelism-label')
  return message === 'parallelism-label' ? 'p (Parallelism)' : message
})

const password = ref('')
const salt = ref<string | File>('')
const isSettingGeneratedSalt = ref(false)
const isAutoGeneratedSalt = ref(false)

const setGeneratedSalt = (format: SaltFormat) => {
  isSettingGeneratedSalt.value = true
  salt.value = generateRandomSalt(format)
  isAutoGeneratedSalt.value = true
  isSettingGeneratedSalt.value = false
}

watch(
  salt,
  () => {
    if (isSettingGeneratedSalt.value) return
    isAutoGeneratedSalt.value = false
  },
  { flush: 'sync' },
)

const saltFormat = useStorage<SaltFormat>('tools:scrypt-key-derivation:salt-format', 'base64')

watch(
  saltFormat,
  (format) => {
    if (salt.value instanceof File) return
    if (!salt.value || isAutoGeneratedSalt.value) {
      setGeneratedSalt(format)
    }
  },
  { immediate: true },
)

watch(password, (nextPassword, previousPassword) => {
  if (!nextPassword || nextPassword === previousPassword) return
  if (salt.value instanceof File) return
  setGeneratedSalt(saltFormat.value)
})
const costFactorInput = useStorage<number | null>(
  'tools:scrypt-key-derivation:cost-factor',
  defaultCostFactor,
)
const blockSizeInput = useStorage<number | null>(
  'tools:scrypt-key-derivation:block-size',
  defaultBlockSize,
)
const parallelismInput = useStorage<number | null>(
  'tools:scrypt-key-derivation:parallelism',
  defaultParallelism,
)
const lengthInput = useStorage<number | null>('tools:scrypt-key-derivation:length', defaultLength)

const parseIntegerRange = (value: number | null, min: number, max: number, fallback: number) => {
  if (value === null) {
    return { value: fallback, isValid: true }
  }

  if (!Number.isFinite(value) || !Number.isInteger(value)) {
    return { value: fallback, isValid: false }
  }

  if (value < min || value > max) {
    return { value: fallback, isValid: false }
  }

  return { value, isValid: true }
}

const isPowerOfTwo = (value: number): boolean => value > 1 && (value & (value - 1)) === 0

const costFactorState = computed(() =>
  parseIntegerRange(costFactorInput.value, minCostFactor, maxCostFactor, defaultCostFactor),
)
const blockSizeState = computed(() =>
  parseIntegerRange(blockSizeInput.value, minBlockSize, maxBlockSize, defaultBlockSize),
)
const parallelismState = computed(() =>
  parseIntegerRange(parallelismInput.value, minParallelism, maxParallelism, defaultParallelism),
)
const lengthState = computed(() =>
  parseIntegerRange(lengthInput.value, minLength, maxLength, defaultLength),
)

const memoryBoundValid = computed(() =>
  isScryptMemoryWithinLimit(costFactorState.value.value, blockSizeState.value.value),
)

const costFactorSafeMax = computed(() =>
  Math.max(
    minCostFactor,
    Math.min(maxCostFactor, getMaxCostFactorForBlockSize(blockSizeState.value.value)),
  ),
)

const blockSizeSafeMax = computed(() =>
  Math.max(
    minBlockSize,
    Math.min(maxBlockSize, getMaxBlockSizeForCostFactor(costFactorState.value.value)),
  ),
)

const costFactorPowerOfTwo = computed(() => isPowerOfTwo(costFactorState.value.value))
const costFactorValid = computed(
  () => costFactorState.value.isValid && costFactorPowerOfTwo.value && memoryBoundValid.value,
)
const blockSizeValid = computed(() => blockSizeState.value.isValid && memoryBoundValid.value)

const saltErrorType = computed((): '' | 'hex' | 'base64' => {
  const saltValue = salt.value
  if (typeof saltValue !== 'string') return ''

  const value = saltValue.trim()
  if (!value) return ''

  if (saltFormat.value === 'hex' && !isValidBase16(value)) {
    return 'hex'
  }

  if (saltFormat.value === 'base64' && !isValidBase64(value)) {
    return 'base64'
  }

  return ''
})
</script>

<i18n lang="json">
{
  "en": {
    "cost-factor-label": "N (Cost Factor)",
    "block-size-label": "r (Block Size)",
    "parallelism-label": "p (Parallelism)"
  },
  "zh": {
    "cost-factor-label": "N（成本因子）",
    "block-size-label": "r（块大小）",
    "parallelism-label": "p（并行度）"
  },
  "zh-CN": {
    "cost-factor-label": "N（成本因子）",
    "block-size-label": "r（块大小）",
    "parallelism-label": "p（并行度）"
  },
  "zh-TW": {
    "cost-factor-label": "N（成本因子）",
    "block-size-label": "r（區塊大小）",
    "parallelism-label": "p（並行度）"
  },
  "zh-HK": {
    "cost-factor-label": "N（成本因子）",
    "block-size-label": "r（區塊大小）",
    "parallelism-label": "p（並行度）"
  },
  "es": {
    "cost-factor-label": "N (factor de costo)",
    "block-size-label": "r (tamaño de bloque)",
    "parallelism-label": "p (paralelismo)"
  },
  "fr": {
    "cost-factor-label": "N (facteur de coût)",
    "block-size-label": "r (taille de bloc)",
    "parallelism-label": "p (parallélisme)"
  },
  "de": {
    "cost-factor-label": "N (Kostenfaktor)",
    "block-size-label": "r (Blockgröße)",
    "parallelism-label": "p (Parallelität)"
  },
  "it": {
    "cost-factor-label": "N (fattore di costo)",
    "block-size-label": "r (dimensione del blocco)",
    "parallelism-label": "p (parallelismo)"
  },
  "ja": {
    "cost-factor-label": "N（コスト係数）",
    "block-size-label": "r（ブロックサイズ）",
    "parallelism-label": "p（並列度）"
  },
  "ko": {
    "cost-factor-label": "N(비용 인자)",
    "block-size-label": "r(블록 크기)",
    "parallelism-label": "p(병렬화)"
  },
  "ru": {
    "cost-factor-label": "N (коэффициент стоимости)",
    "block-size-label": "r (размер блока)",
    "parallelism-label": "p (параллелизм)"
  },
  "pt": {
    "cost-factor-label": "N (fator de custo)",
    "block-size-label": "r (tamanho de bloco)",
    "parallelism-label": "p (paralelismo)"
  },
  "ar": {
    "cost-factor-label": "N (عامل الكلفة)",
    "block-size-label": "r (حجم الكتلة)",
    "parallelism-label": "p (التوازي)"
  },
  "hi": {
    "cost-factor-label": "N (कॉस्ट फ़ैक्टर)",
    "block-size-label": "r (ब्लॉक आकार)",
    "parallelism-label": "p (पैरेललिज़्म)"
  },
  "tr": {
    "cost-factor-label": "N (maliyet faktörü)",
    "block-size-label": "r (blok boyutu)",
    "parallelism-label": "p (paralellik)"
  },
  "nl": {
    "cost-factor-label": "N (kostenfactor)",
    "block-size-label": "r (blokgrootte)",
    "parallelism-label": "p (parallelisme)"
  },
  "sv": {
    "cost-factor-label": "N (kostnadsfaktor)",
    "block-size-label": "r (blockstorlek)",
    "parallelism-label": "p (parallellism)"
  },
  "pl": {
    "cost-factor-label": "N (współczynnik kosztu)",
    "block-size-label": "r (rozmiar bloku)",
    "parallelism-label": "p (równoległość)"
  },
  "vi": {
    "cost-factor-label": "N (hệ số chi phí)",
    "block-size-label": "r (kích thước khối)",
    "parallelism-label": "p (mức song song)"
  },
  "th": {
    "cost-factor-label": "N (ตัวคูณต้นทุน)",
    "block-size-label": "r (ขนาดบล็อก)",
    "parallelism-label": "p (ระดับการทำงานขนาน)"
  },
  "id": {
    "cost-factor-label": "N (faktor biaya)",
    "block-size-label": "r (ukuran blok)",
    "parallelism-label": "p (paralelisme)"
  },
  "he": {
    "cost-factor-label": "N (מקדם עלות)",
    "block-size-label": "r (גודל בלוק)",
    "parallelism-label": "p (מקביליות)"
  },
  "ms": {
    "cost-factor-label": "N (faktor kos)",
    "block-size-label": "r (saiz blok)",
    "parallelism-label": "p (paralelisme)"
  },
  "no": {
    "cost-factor-label": "N (kostnadsfaktor)",
    "block-size-label": "r (blokkstørrelse)",
    "parallelism-label": "p (parallellitet)"
  }
}
</i18n>
